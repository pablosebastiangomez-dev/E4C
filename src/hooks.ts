// Este archivo está pensado para hooks personalizados.
// Puedes agregar aquí tus propios hooks de React para reutilizar lógica en tus componentes.

import { useState, useEffect, useCallback } from 'react';
import { supabase } from './supabaseClient';

interface UseSupabaseCrudReturn<T> {
  data: T[] | null;
  loading: boolean;
  error: string | null;
  createItem: (item: Omit<T, 'id'>) => Promise<void>; // Assuming 'id' is generated by DB
  updateItem: (id: string, item: Partial<T>) => Promise<void>;
  removeItem: (id: string) => Promise<void>;
  refresh: () => void; // Function to manually trigger a re-fetch
}

export const useSupabaseCrud = <T extends { id: string }>(
  tableName: string
): UseSupabaseCrudReturn<T> => {
  const [data, setData] = useState<T[] | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      const { data: supabaseData, error: supabaseError } = await supabase
        .from(tableName)
        .select('*');

      if (supabaseError) {
        throw supabaseError;
      }

      setData(supabaseData as T[]);
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [tableName, refreshTrigger]); // Add refreshTrigger to dependencies

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const refresh = useCallback(() => {
    setRefreshTrigger(prev => prev + 1);
  }, []);

  const createItem = useCallback(
    async (item: Omit<T, 'id'>) => {
      try {
        setLoading(true);
        const { data: newItems, error: createError } = await supabase
          .from(tableName)
          .insert(item as any) // Supabase type requires any for Omit<T, 'id'>
          .select(); // Select the newly inserted item to get its ID

        if (createError) {
          throw createError;
        }

        if (newItems) {
            setData(prev => (prev ? [...prev, ...(newItems as T[])] : (newItems as T[])));
        }
        refresh(); // Re-fetch all data to ensure consistency
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    },
    [tableName, refresh]
  );

  const updateItem = useCallback(
    async (id: string, item: Partial<T>) => {
      try {
        setLoading(true);
        const { error: updateError } = await supabase
          .from(tableName)
          .update(item)
          .eq('id', id);

        if (updateError) {
          throw updateError;
        }
        refresh(); // Re-fetch all data to ensure consistency
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    },
    [tableName, refresh]
  );

  const removeItem = useCallback(
    async (id: string) => {
      try {
        setLoading(true);
        const { error: deleteError } = await supabase
          .from(tableName)
          .delete()
          .eq('id', id);

        if (deleteError) {
          throw deleteError;
        }
        refresh(); // Re-fetch all data to ensure consistency
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    },
    [tableName, refresh]
  );

  return { data, loading, error, createItem, updateItem, removeItem, refresh };
};
